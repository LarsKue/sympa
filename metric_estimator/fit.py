
import torch
import numpy as np

from .model import ModelMixin
from .device import device


class ModelFitMixin(ModelMixin):
    """
    Fit a model to data generated by a DataLoader
    Keep a history of losses throughout training
    """

    def __init__(self, *layers, optimizer, loss, train_loader, val_loader, batch_shape=None):
        super(ModelFitMixin, self).__init__(*layers)
        self.optimizer = optimizer
        self.loss = loss
        self.train_loader = train_loader
        self.val_loader = val_loader
        self.batch_shape = batch_shape
        self.train_loss = []
        self.val_loss = []

    def fit(self, epochs, validate=True, verbose=False):
        """
        Train for a fixed number of epochs and keep a loss history
        """
        for epoch in range(epochs):
            train_loss = self.step_train()
            self.train_loss.append(train_loss)

            if validate:
                val_loss = self.step_val()
                self.val_loss.append(val_loss)
            else:
                val_loss = None

            if verbose:
                print(f"Epoch {epoch + 1}:")
                print("Train Loss:", train_loss)
                print("Validation Loss:", val_loss)
                print()

    def step_train(self):
        """
        Perform one Training Step
        """
        temp = self.model.training
        self.model.train(mode=True)

        batch_losses = []
        for batch, (x, y) in enumerate(self.train_loader):
            x = x.to(device)
            if self.batch_shape is not None:
                x = x.view(self.batch_shape)

            y = y.to(device)

            self.optimizer.zero_grad(set_to_none=True)
            yhat = self.model(x)
            batch_loss = self.loss(yhat, y)
            batch_loss.backward()
            self.optimizer.step()

            batch_losses.append(batch_loss.detach().item())

        self.model.train(mode=temp)
        return np.mean(batch_losses)

    def step_val(self):
        """
        Perform one Validation Step
        """
        temp = self.model.training
        self.model.train(mode=False)

        batch_losses = []
        for batch, (x, y) in enumerate(self.val_loader):
            x = x.to(device)
            if self.batch_shape is not None:
                x = x.view(self.batch_shape)

            y = y.to(device)

            with torch.no_grad():
                yhat = self.model(x)
                batch_loss = self.loss(yhat, y)

                batch_losses.append(batch_loss.detach().item())

        self.model.train(mode=temp)
        return np.mean(batch_losses)
